# گزارش آزمایش
همانطور که در دستور کار خواسته شده است، در این آزمایش هر کامیت معادل با یک یا چند refactor است که در پیام کامیت، مشخص است که چه نوع بازآرایی انجام شده است. در ادامه، انواع مختلف refactor هایی که در این آزمایش انجام شده اند، بررسی خواهند شد:

### Replace Conditional with Polymorphism
در این سناریو، یک switch statement در کد وجود دارد که می‌تواند با ساختاری شامل یک کلاس پایه و تعدادی کلاس ارث‌برنده از آن کلاس پایه، جایگزین شود. تصویری از این سناریو که در کد وجود دارد، به صورت زیر آورده شده است:

<img width="1511" alt="Screenshot 1402-05-20 at 23 55 23" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/78a3cf44-237f-4507-b83c-20b403fa0af2">

در اینجا، برای متد toString چندین نوع مختلف فرض شده است که این انواع مختلف، با caseهای مختلف هندل شده‌اند. حال قرار است این تکه از کد بازآرایی شود. مطابق تصویر زیر، تعدادی کلاس ایجاد شده‌اند که همگی از کلاس پایه Address ارث‌بری می‌کنند و در این کلاس‌ها، متد toString مخصوص خودشان پیاده‌سازی شده است. بدین شکل، چندریختی جایگزین ساختار شرطی اولیه شده است. تغییرات کامل در کامیتی با نام بازآرایی گفته شده، موجود است:

<img width="1496" alt="Screenshot 1402-05-20 at 23 58 09" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/9960ad0f-5c87-45d6-aec8-8412cf30b740">


### Facade in parser
این الگو زمانی کارآمد است که دو زیرسیستم وجود داشته باشد و عناصر داخلی این دو زیر سیستم به هم وابستگی داشته باشند و اصطلاحا coupling وجود داشته باشد. در این سناریو، به ازای هر زیرسیستم، یک واسط ایجاد می‌شود و پس از این تمام ارتباطات بین اجزای این دو زیرسیستم، فقط از طریق این دو واسط انجام می‌شود. در مثالی که در آزمایش وجود دارد، برای زیرسیستم parser، یک واسط به صورت زیر ایجاد و استفاده شده است. یعنی کلاس Main به جای آنکه مستقیما با کلاس parser ارتباط برقرار کند، با واسط آن ارتباط برقرار می‌کند:

<img width="1511" alt="Screenshot 1402-05-21 at 00 07 10" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/0fc66c11-e8f1-44ad-9160-0a2863306d81">


<img width="1481" alt="Screenshot 1402-05-21 at 00 05 47" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/83869c25-3e53-4251-b9b4-75ea64ac760e">

### Facade in parser
مورد دومی که از بازآرایی facade در این آزمایش وجود دارد، این است که در کلاس CodeGenerator، ارتباط‌های زیادی با کلاس‌های concrete از Symbol وجود دارد. به همین علت، برای کلاس symbol، مطابق شکل زیر، یک واسط SymbolFacade ایجاد شده است که پس از این تمام ارتباط‌های این دو کلاس از طریق این واسط انجام بشود:

<img width="1512" alt="Screenshot 1402-05-21 at 08 56 53" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/ed61d78b-f79a-469b-aafb-1a19e48d3efe">

در ادامه در تصویر زیر، قسمتی از پیاده‌سازی و متد‌های موجود در واسط SymbolFacade آورده شده است تا تمام ارتباطات میان این کلاس و گلاس‌های دیگر پوشش داده شود:

<img width="1512" alt="Screenshot 1402-05-21 at 09 05 35" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/4953203f-e34f-4bff-8529-ac6316726929">


### Separate query from modifier
 برای درک این نمونه از بازآرایی، فرض کنید متدی وجود دارد که یک مقدار از یک object را درون خود تغییر می‌دهد ولی در کنار این کار، یک مقدار دیگری را هم return می‌کند. می‌توان این متد را در دو متد دیگر بازآرایی گرد به این صورت که یک متد، کار query یا get کردن را انجام می‌دهد و یک متد دیگر کار modify کردن را انجام می‌دهد. در مثال این آزمایش، یک متد کلی main وجود دارد که در ۲ متد queryMain و modifyMain بازآرایی شده است. متد اول، کار بازیابی query و بازگرداندن مقدار خواسته شده را انجام می‌دهد و متد دوم، اضافه کردن متد به جدول و modify کردن را انجام می‌دهد.
 
<img width="1512" alt="Screenshot 1402-05-21 at 08 14 20" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/308bb4e2-5207-48a1-a4f5-ceb920f35b17">


### Fix DIP
همانطور که در ویدیوی موجود در سایت آپارات گفته شد، به جای استفاده از عبارت 
```
private ArrayList<Rule> rules = new ArrayList<Rule>();
```
در کد، بهتر است از عبارت 
```
private List<Rule> rules = new ArrayList<Rule>();
```
استفاده شود تا DIP نقض نشود. کلاس ArrayList که یک کلاس concrete است، واسط List را پیاده‌سازی می‌کند. اگر از مقداردهی اول استفاده کنیم، هر گونه تغییراتی که در arraylist داده شود، ممکن است موجب از کار افتادن کد و به خطا افتادن کاربر بشود. اما چون List یک واسط است و مانع از انتشار تغییرات به کاربر می‌شود، هر گونه تغییرات در arraylist کد را دچار مشکل نمی‌کند و DIP نقض نمی‌شود. تصویر این تغییرات به شکل زیر است:
<img width="1504" alt="Screenshot 1402-05-21 at 00 12 35" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/f7ac2121-7262-4f0d-abfd-51b2f022ec7b">

### Replace error code with exception
در این نوع از بازآرایی، به جای آن که برای خطاها کدگذاری شود و آن کد خروجی داده شود و در ادامه، اجرای برنامه متوقف شود، از ساختار try-catch در جاوا استفاده می‌شود. در این روش، در بلوک catch، اقدامات لازم برای اطلاع‌رسانی به کاربر در مورد خطا انجام می‌شود ولی اجرای برنامه متوقف نمی‌شود و برنامه crash نمی‌کند. نمونه‌ای از این بازآرایی مطابق شکل زیر است:

<img width="1510" alt="Screenshot 1402-05-21 at 07 57 38" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/6b5a6214-5b0a-4834-ab5e-b576e67f6476">

### Decompose Conditional
در بدنه ساختار if-else، اگر شرط‌ها و یا عملیاتی که در اثر برقراری شرط‌ها انجام می‌شوند، پیچیده و طولانی باشند، می‌توان آنها را در قالب یک متد خلاصه کرد و صرفا در ساختار شرطی، آن متدها را فراخوانی کرد. به طور مثال، در ساختار زیر، دو متد اضافه شده است که بدنه‌ آنها حاوی شرط‌های پیچیده‌ای که در مقابل ifها وجود دارند، می‌باشد. به این صورت، مطابق شکل زیر، تنها لازم است آن دو متد در شرط‌های if فراخوانی شود تا برقراری شرط‌ها بررسی شود:

<img width="1512" alt="Screenshot 1402-05-21 at 08 00 39" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/cbdad377-14c1-4c8e-b05f-59bf5c0c4ee4">



### Extract Method
در این دسته از بازآرایی، تکه‌ کدهایی که به هم مربوط هستند و در عمل با یکدیگر یک کارایی خاص را انجام می‌دهند، به یک ماژول یا تابع جداگانه منتقل می‌شوند و پس از این برای استفاده از آن تکه کد، صرفا تابع مورد نظر فراخوانی می‌شود. این مورد به خوانایی و قابل فهم بودن کد کمک بسیار زیادی می‌کند. نمونه‌ای از این بازآرایی که در این آزمایش انجام شده است، در تصویر زیر مشخص است:
<img width="1498" alt="Screenshot 1402-05-20 at 21 50 44" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/c8527e78-792e-44ac-be74-1d9ebba37767">
در تصویر بالا، یک تابع جدید به نام pushAddress تعریف شده است و محتویات آن، تکه کد منسجمی است که قبل از قراخوانی این تابع وجود داشته و اکنون به بدنه تابع منتقل شده است. بدین صورت، هر زمان که احتیاج به آن تکه کد منسجم باشد، صرفا تابع pushAddress را فراخوانی می‌کنیم. 


### Hide Methods
در این نمونه از بازآرایی، نوع توابعی از کلاس که خارج از آن کلاس نباید به آن دسترسی داشت، از public به private تغییر داده می‌شود. تصویری از این بازآرایی در ادامه آورده شده است:

<img width="1510" alt="Screenshot 1402-05-21 at 07 53 09" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/4a2c5c80-d420-47e0-a36d-a5e3647ab664">


### Remove comments
همانطور که از نام این دسته مشخص است، صرفا کامنت‌هایی که در کد وجود دارند و تاثیری در عملکرد کد ندارد، حذف شده‌اند. نمونه‌ای از این بازآرایی که در این آزمایش انجام شده است، در تصویر زیر مشخص است:
<img width="1468" alt="Screenshot 1402-05-20 at 21 48 41" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/fe9c2e6f-b655-42a2-9e4f-53ba2ec14729">




# پاسخ سوالات مطرح شده در دستور کار

## سوال اول
#### کد تمیز
کد تمیز، اصطلاحی از توسعه نرم‌افزار است که به پیاده‌سازی واضح و خوانا، قابل درک، قابل ردیابی، منطقی، تغییرپذیر (maintainable) و منظم کد می پردازد.
#### بدهی فنی
بدهی فنی یا technical debt زمانی رخ می‌دهد که در مواجهه با یک مسئله، راه‌حل سریع‌تر و آسان‌تر (اما محدودتر) به جای راه‌حل کاراتر ولی زمانبر انتخاب می‌شود. این موضوع باعث می‌شود که در آینده مجبور باشیم هزینه زمانی و انسانی اضافه‌تری پرداخت کنیم تا مشکل به طور کامل حل شود. به این هزینه‌ای که در آینده باید پرداخت شود، بدهی فنی می‌گویند.
#### بوی بد
بوی بد کد یا code smells، یه مشکلات و یا ضعف‌های باالقوه کد اشاره می‌کند که ممکن است کارایی و عملکرد نرم‌افزار را تحت تاثیر قرار دهند. بوی بد معمولا از کدنویسی ضعیف و یا بدون قاعده ناشی می‌شود. همچنین، بودی بد لزوما به یک خطا و مشکل در نرم‌افزار اشاره نمی‌کند، بلکه می‌تواند خوانایی کد و توانایی maintainance آن را از بین ببرد.



## سوال دوم
همانطور که در صورت سوال گفته شده است، ۵ دسته از انواع بوی بد کد وجود دارد که در ادامه، در مورد هر کدام از آنها توضیحاتی ارائه شده است:
### ‌‌Bloaters
این دسته به کدها یا توابع یا کلاس‌هایی اشاره دارد که به بیش از اندازه بزرگ و حجیم هستند، به طوری که فهم آنها و کار کردن با آنها و یا حتی maintain کردن آنها دشوار می‌شود. به طور مثال، می‌توان به کلاس‌هایی اشاره کرد که به اصطلاح همه‌کاره هستند و بقیه کلاس‌ها مجبورند دائم با این ابرکلاس در ارتباط باشند تا داده‌های لازم را دریافت کنند.

### Object-Orientation Abusers
این دسته به استفاده‌های نادرست از اصول شی‌ء گرایی (نظیر چندریختی و یا وراثت) اشاره می‌کند. نمونه‌ای از این دسته که در همین آزمایش به آن پرداخته شده است، استفاده از switch statement است که باید با چندریختی جایگزین شود.

### Change Preventers
این دسته به مواردی اشاره دارد که وقتی قرار است تکه کدی در یک کلاس یا تابع تغییر کند، مجبور باشیم در چند جای دیگر از کد هم تغییرات را اعمال کنیم. نمونه‌ای از این دسته، shotgun surgery است که در آن، برای آنکه یک تغییر در یک کلاس اعمال شود، مجبور هستیم به طور همزمان تغییراتی را در کلاس‌های دیگر هم انجام دهیم.

### Dispensables
این دسته به مواردی اشاره دارد که بود و نبود آنها در کارایی کد تاثیری ندارد و نیازی به آنها در کد وجود ندارد. مثال بسیار رایجی که از این دسته وجود دارد و در این آزمایش هم به آن پرداخته شده است، وجود commentها در کد است.

### Couplers
این دسته به مواردی اشاره دارد که وابستگی و coupling شدیدی میان کلاس‌ها وجود دارد و یا از آن طرف، به جای coupling و وابستگی، delegation (برون‌سپاری) بسیار شدیدی در کلاس‌ها وجود دارد و کلاس‌ها مدام کارها را به یکدیگر می‌سپارند. هر دو حالت، موارد نامطلوبی هستند که باید از آنها جلوگیری کرد.
