# گزارش آزمایش
همانطور که در دستور کار خواسته شده است، در این آزمایش هر کامیت معادل با یک یا چند refactor است که در پیام کامیت، مشخص است که چه نوع بازآرایی انجام شده است. در ادامه، انواع مختلف refactor هایی که در این آزمایش انجام شده است را بررسی می‌کنیم:

### Replace Conditional with Polymorphism
در این سناریو، یک switch statement در کد وجود دارد که می‌تواند با ساختاری شامل یک کلاس پایه و تعدادی کلاس ارث‌برنده از آن کلاس پایه، جایگزین شود. تصویری از این سناریو که در کد وجود دارد، به صورت زیر آورده شده است:

<img width="1511" alt="Screenshot 1402-05-20 at 23 55 23" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/78a3cf44-237f-4507-b83c-20b403fa0af2">

در اینجا، برای متد toString چندین نوع مختلف فرض شده است که این انواع مختلف، با caseهای مختلف هندل شده‌اند. حال قرار است این تکه از کد بازآرایی شود. مطابق تصویر زیر، تعدادی کلاس ایجاد شده‌اند که همگی از کلاس پایه Address ارث‌بری می‌کنند و در این کلاس‌ها، متد toString مخصوص خودشان پیاده‌سازی شده است. بدین شکل، چندریختی جایگزین ساختار اولیه شده است. تغییرات کامل در کامیتی با نام بازآرایی گفته شده، موجود است:

<img width="1496" alt="Screenshot 1402-05-20 at 23 58 09" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/9960ad0f-5c87-45d6-aec8-8412cf30b740">



### Remove comments
همانطور که از نام این دسته مشخص است، صرفا کامنت‌هایی که در کد وجود دارند و تاثیری در عملکرد کد ندارد، حذف شده‌اند. نمونه‌ای از این بازآرایی که در این آزمایش انجام شده است، در تصویر زیر مشخص است:
<img width="1468" alt="Screenshot 1402-05-20 at 21 48 41" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/fe9c2e6f-b655-42a2-9e4f-53ba2ec14729">



### Extract Method
در این دسته از بازآرایی، تکه‌ کدهایی که به هم مربوط هستند و در عمل با یکدیگر یک کارایی خاص را انجام می‌دهند، به یک ماژول یا تابع جداگانه منتقل می‌شوند و پس از این برای استفاده از آن تکه کد، صرفا تابع مورد نظر فراخوانی می‌شود. این مورد به خوانایی و قابل فهم بودن کد کمک بسیار زیادی می‌کند. نمونه‌ای از این بازآرایی که در این آزمایش انجام شده است، در تصویر زیر مشخص است:
<img width="1498" alt="Screenshot 1402-05-20 at 21 50 44" src="https://github.com/MoaliMkh/SELab_4/assets/59166192/c8527e78-792e-44ac-be74-1d9ebba37767">
در تصویر بالا، یک تابع جدید به نام pushAddress تعریف شده است و محتویات آن، تکه کد منسجمی است که قبل از قراخوانی این تابع وجود داشته و اکنون به بدنه تابع منتقل شده است. بدین صورت، هر زمان که احتیاج به آن تکه کد منسجم باشد، صرفا تابع pushAddress را فراخوانی می‌کنیم. 



# پاسخ سوالات مطرح شده در دستور کار

## سوال اول
#### کد تمیز
کد تمیز، اصطلاحی از توسعه نرم‌افزار است که به پیاده‌سازی واضح و خوانا، قابل درک، قابل ردیابی، منطقی، تغییرپذیر (maintainable) و منظم کد می پردازد.
#### بدهی فنی
بدهی فنی یا technical debt زمانی رخ می‌دهد که در مواجهه با یک مسئله، راه‌حل سریع‌تر و آسان‌تر (اما محدودتر) به جای راه‌حل کاراتر ولی زمانبر انتخاب می‌شود. این موضوع باعث می‌شود که در آینده مجبور باشیم هزینه زمانی و انسانی اضافه‌تری پرداخت کنیم تا مشکل به طور کامل حل شود. به این هزینه‌ای که در آینده باید پرداخت شود، بدهی فنی می‌گویند.
#### بوی بد
بوی بد کد یا code smells، یه مشکلات و یا ضعف‌های باالقوه کد اشاره می‌کند که ممکن است کارایی و عملکرد نرم‌افزار را تحت تاثیر قرار دهند. بوی بد معمولا از کدنویسی ضعیف و یا بدون قاعده ناشی می‌شود. همچنین، بودی بد لزوما به یک خطا و مشکل در نرم‌افزار اشاره نمی‌کند، بلکه می‌تواند خوانایی کد و توانایی maintainance آن را از بین ببرد.



## سوال دوم
همانطور که در صورت سوال گفته شده است، ۵ دسته از انواع بوی بد کد وجود دارد که در ادامه، در مورد هر کدام از آنها توضیحاتی ارائه شده است:
### ‌‌Bloaters
این دسته به کدها یا توابع یا کلاس‌هایی اشاره دارد که به بیش از اندازه بزرگ و حجیم هستند، به طوری که فهم آنها و کار کردن با آنها و یا حتی maintain کردن آنها دشوار می‌شود. به طور مثال، می‌توان به کلاس‌هایی اشاره کرد که به اصطلاح همه‌کاره هستند و بقیه کلاس‌ها مجبورند دائم با این ابرکلاس در ارتباط باشند تا داده‌های لازم را دریافت کنند.

### Object-Orientation Abusers
این دسته به استفاده‌های نادرست از اصول شی‌ء گرایی (نظیر چندریختی و یا وراثت) اشاره می‌کند. نمونه‌ای از این دسته که در همین آزمایش به آن پرداخته شده است، استفاده از switch statement است که باید با چندریختی جایگزین شود.

### Change Preventers
این دسته به مواردی اشاره دارد که وقتی قرار است تکه کدی در یک کلاس یا تابع تغییر کند، مجبور باشیم در چند جای دیگر از کد هم تغییرات را اعمال کنیم. نمونه‌ای از این دسته، shotgun surgery است که در آن، برای آنکه یک تغییر در یک کلاس اعمال شود، مجبور هستیم به طور همزمان تغییراتی را در کلاس‌های دیگر هم انجام دهیم.

### Dispensables
این دسته به مواردی اشاره دارد که بود و نبود آنها در کارایی کد تاثیری ندارد و نیازی به آنها در کد وجود ندارد. مثال بسیار رایجی که از این دسته وجود دارد و در این آزمایش هم به آن پرداخته شده است، وجود commentها در کد است.

### Couplers
این دسته به مواردی اشاره دارد که وابستگی و coupling شدیدی میان کلاس‌ها وجود دارد و یا از آن طرف، به جای coupling و وابستگی، delegation (برون‌سپاری) بسیار شدیدی در کلاس‌ها وجود دارد و کلاس‌ها مدام کارها را به یکدیگر می‌سپارند. هر دو حالت، موارد نامطلوبی هستند که باید از آنها جلوگیری کرد.
